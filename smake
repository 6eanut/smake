#!/usr/bin/env bash
# smake -- generates analysis rules from make rules
# Author: Jaeho Shin <netj@ropas.snu.ac.kr>
# Created: 2006-01-11
Revision=r1045
CCHooks=(gcc g++ cc c++ clang clang++ cpp as ld ar wllvm gclang)
Hooks=(rm mv cp ln)

if [ -z "$SMAKEDIRpath" ]; then
  SMAKEDIRpath=sparrow
fi

which realpath >/dev/null
if [[ $? == 1 ]]; then
  realpath="readlink -f"
else
  realpath="realpath"
fi
Base="$($realpath "$0")"
Base="$(dirname "$Base")"
Base=$(cd "$Base" && pwd || echo "$Base")

set -e

realpath() {
  case "$1" in
    /*) echo "$1" ;;
    *) echo "$PWD/$1" ;;
  esac
}

main() {
  case "$1" in
    ## usage
    --help)
      cat <<EOF
smake $Revision
  a program analysis preparation tool for C programs made with GNU Make

smake observes the build process driven by make(1), and derives the
standalone, preprocessed form of the source code that makes up each
C program linked during the process.  smake creates a directory
"$SMAKEDIRpath/", where you can perform program analyses with make(1).

You can instantly start your program analysis in three steps:
 1. Initialize "$SMAKEDIRpath/", i.e. \$SMAKEDIR.
 2. Use \`smake\` instead of \`make\` to build your programs.
 3. Use \`make\` under \$SMAKEDIR to analyze your programs.

Usage:
 $ smake --init [<options>]
  initializes $SMAKEDIRpath/ to handle the regular use of smake.
  If you use a special compiler (e.g. cross compiler), its type must be
  specified by appending gcc style options, e.g. \`-b mips-linux -V 2.95\`.

 $ smake --clean
  completely removes $SMAKEDIRpath/.

 $ smake <parameters for make>
  runs \`make [<with parameters>]\` and bookkeeps \$SMAKEDIR.

 $ smake ./configure
  runs \`./configure\` under the same environment \`smake\` runs.

 $ smake --help
  shows this message.

EOF
      ;;

    ## initialize $SMAKEDIR
    --init)
      shift
      if [ -n "$SMAKEDIR" ]; then
        # if SMAKEDIR is specified
        SMAKEDIR=$(realpath "$SMAKEDIR")
        dir=$SMAKEDIR
      else
        # otherwise, use default
        # detect and warn the presence of $SMAKEDIRpath in parents( of parents)*?
        find_SMAKEDIR && confirm "smake: $SMAKEDIR/ exists, override it? "
        # use default
        SMAKEDIR="$PWD/$SMAKEDIRpath"
        dir=$SMAKEDIRpath
      fi
      #[ -d "$SMAKEDIR" ] && abort "smake: $dir/ exists!  You cannot initialize twice."
      SMAKEROOT=$PWD
      HookBase="$SMAKEDIR/.bin"
      # create $SMAKEDIR and the Makefile for analysis
      AnalyzerPath=$(realpath "$0")
      mkdir -p "$SMAKEDIR"
      cd "$SMAKEDIR"
      cat >Makefile <<EOF
# Makefile for analyzing programs made with Makefiles under:
#  $SMAKEROOT
#
# Generated at $(now)
#           by smake($Revision) --init $@.

ANALYZE?=$(dirname "$AnalyzerPath")/$SMAKEDIRpath
TGTS=\$(shell cat .targets | sed -e 's/\$\$/.$SMAKEDIRpath/')

ifneq (\$(origin STEST),undefined)
export OPTS=-uidebug
export REDIRECTION=2>&1 | tee \$@.log
endif

.PHONY: help banner targets all clean update
help: banner targets
banner:
	@\$(ANALYZE) | sed -ne '1,/^\$\$/p'

\$(TGTS):
	\$(ANALYZE) \$(SPARROW_OPTS) \$(OPTS) -report=\$@ \$(@:%.$SMAKEDIRpath=%)/* \$(REDIRECTION)

targets:
	@echo "Following <target>s are ready to be analyzed:"
	@for p in \$(TGTS); do echo "  \$\$p"; done
	@echo
	@echo "Run 'make all' to analyze everything,"
	@echo "or you may specify the targets as 'make <target> ...'."

all: \$(TGTS)
clean:
	rm -rf \$(TGTS)
EOF

      touch .targets
      ln -sf "$SMAKEROOT" .root
      #  setup HookBase
      mkdir -p "$HookBase"
      hooks "$@" | while read; do
        # symlink to the hook with command names we want to monitor
        ln -sf "$Base/hook" "$HookBase/$REPLY"
      done
      #  log file
      {
        echo "### Generated by smake($Revision) --init $@"
        echo "###           at $(now)"
      } >.smake.log
      ;;

    ## clean up
    --clean)
      if [ -n "$SMAKEDIR" ]; then
        # if SMAKEDIR is specified
        dir=$SMAKEDIR
      else
        # otherwise, use default
        SMAKEDIR="$PWD/$SMAKEDIRpath"
        dir=$SMAKEDIRpath
      fi
      # check if SMAKEDIR exists
      [ -d "$SMAKEDIR" ] || abort "smake: It is clean here, there is no $dir/."
      echo -n "smake: Cleaning up... "
      rm -rf "$SMAKEDIR"
      echo "Removed $dir/."
      ;;

    ## ./configure with the same $PATH make will be run
    ./configure)
      must_be_initialized
      PATH="$HookBase:$PATH" \
        run "$@"
      ;;

    ## follow make rules
    *)
      must_be_initialized
      SMAKECONFIGURE=false \
        PATH="$HookBase:$PATH" \
        run make "$@"
      ;;
  esac
}

now() { LC_ALL=C date +"%c %z"; }

abort() {
  echo "$@"
  exit 2
}

confirm() {
  echo -n "$@"
  read
  case "$REPLY" in
    [Yy]) true ;;
    *) false ;;
  esac
}

run() {
  local signals="ERR INT HUP QUIT TERM"
  {
    echo
    echo "## Running $@"
    echo "## Started at $(now)"
  } >>"$SMAKEDIR/.smake.log"
  log_error() {
    local exitcode=$?
    trap "" $signals
    echo "## Aborted with exit code $exitcode at $(now)" >>"$SMAKEDIR/.smake.log"
    exit $?
  }
  trap log_error $signals
  "$@"
  echo "## Finished at $(now)" >>"$SMAKEDIR/.smake.log"
  echo "smake: recorded activities in $SMAKEDIR/."
}

# find a parent who has $SMAKEDIRpath and set SMAKEDIR, SMAKEROOT
find_SMAKEDIR() {
  local dir=$PWD
  # look upwards, find the directory that has $SMAKEDIRpath
  until [ -e "$dir/$SMAKEDIRpath/.smake.log" -o "${dir:-/}" = / ]; do
    dir=$(cd "$dir"/.. && pwd || echo /)
  done
  if [ -d "$dir/$SMAKEDIRpath" ]; then
    # set variables if found
    SMAKEDIR=$(cd "$dir" && cd "$SMAKEDIRpath" && pwd)
    SMAKEROOT=$(readlink "$SMAKEDIR/.root" || echo "$dir")
    export SMAKEDIR SMAKEROOT
    HookBase="$SMAKEDIR/.bin"
    true
  else
    false
  fi
}

must_be_initialized() {
  if [ -d "$SMAKEDIR" ] || find_SMAKEDIR; then
    true
  else
    $0 --help
    echo "smake: No \$SMAKEDIR found.  Run \`smake --init\` first."
    exit 2
  fi
}

hooks() {
  local machine= version= o
  while getopts "b:V:" o; do
    case "$o" in
      b) machine=$OPTARG ;;
      V) version=$OPTARG ;;
    esac
  done
  local h
  # compiler suites
  for h in "${CCHooks[@]}"; do
    echo "${machine:+$machine-}$h${version:+-$version}"
  done
  # common utilities
  for h in "${Hooks[@]}"; do
    echo "$h"
  done
}

prefix() {
  local h=$1
  shift
  local machine= version= o
  while getopts "b:V:" o; do
    case "$o" in
      b) machine=$OPTARG ;;
      V) version=$OPTARG ;;
    esac
  done
  echo "${machine:+$machine-}$h${version:+-$version}"
}

main "$@"
